//
//  TRState.m
//  Chowderios
//
//  Created by Pedro Gomes on 06/02/2014.
//  Copyright (c) 2014 Thomson Reuters Global Resources.  All Rights Reserved.  Proprietary and confidential information of TRGR.  Disclosure, use, or reproduction without written authorization of TRGR is prohibited. All rights reserved.
//

#import "TRState.h"
#import "TRStateMachine.h"
#import "TRStateTransitionProtocol.h"

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@interface TRState ()

@property (nonatomic, copy) NSString *identifier;
@property (nonatomic, strong) NSMutableDictionary *transitions;

@end

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@implementation TRState

@synthesize owner = _owner;

#pragma mark - Dealloc and Initialization

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (instancetype)initWithIdentifier:(NSString *)identifier
{
    if((self = [super init])) {
        self.identifier  = identifier;
        self.transitions = [NSMutableDictionary dictionary];
    }
    return self;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (id)copyWithZone:(NSZone *)zone
{
    TRState *copy = [[[self class] alloc] initWithIdentifier:self.identifier];
    copy.transitions = [self.transitions copy];
    return copy;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (NSUInteger)hash
{
    return self.identifier.hash;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (BOOL)isEqual:(id)object
{
    if(self == object) return YES;
    if([object isKindOfClass:[self class]] == NO) return NO;
    
    return ([((TRState *)object).identifier isEqualToString:self.identifier]);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (NSString *)description
{
    return [NSString stringWithFormat:@"<%@ %p: identifier: %@>",
            NSStringFromClass([self class]),
            self,
            self.identifier];
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (void)printTransitions
{
    NSLog(@"%@", [self stringRepresentation]);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (NSString *)stringRepresentation
{
    NSMutableString *output = [[NSMutableString alloc] init];
    if(self.transitions.count > 0) {
        [self.transitions enumerateKeysAndObjectsUsingBlock:^(id<TRStateTransition> transition, id<TRState> toState, BOOL *stop) {
            [output appendFormat:@"\t%@ -> %@ [label=\" %@\"];\n", self.identifier, toState.identifier, transition.identifier];
        }];
    }
    return output;
}

#pragma mark - Public Methods

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (void)addTransition:(id<TRStateTransition>)transition toState:(id<TRState>)state
{
    // add checks and exception (pdcgomes 06.02.2014)
    if(self.transitions[transition] != nil) {
        [NSException raise:TRStateMachineDuplicateTransitionException
                    format:@"Transition <%@> has been previously defined", transition.identifier];
    }
    
    if([self isEqual:state] == YES) {
        [NSException raise:TRStateMachineInvalidTransitionException
                    format:@"Initial state and destination states must be different"];
    }
    
    self.transitions[transition] = state;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (void)deleteTransition:(id<TRStateTransition>)transition
{
    // add checks and exception (pdcgomes 06.02.2014)
    if(self.transitions[transition] == nil) {
        [NSException raise:TRStateMachineInvalidTransitionException
                    format:@"Transition <%@> was never registered", transition.identifier];
    }
    [self.transitions removeObjectForKey:transition];
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (id<TRState>)stateForTransition:(id<TRStateTransition>)transition
{
//    if(self.transitions[transition] == nil) {
//        [NSException raise:TRStateMachineInvalidTransitionException
//                    format:@"Transition <%@> is undefined for state <%@>", transition.identifier, self.identifier];
//    }
    return [self.transitions objectForKey:transition];
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (void)enter
{
    
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (void)exit
{
    
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (void)execute
{
    
}

#pragma mark - Private Methods

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
- (BOOL)_validateTransition:(id<TRStateTransition>)transition
                    toState:(id<TRState>)toState
{
    if([toState isEqual:self] == YES) {
        return NO;
    }

    return NO;
}

@end

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@implementation TRStartState

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
+ (instancetype)state
{
    return [[[self class] alloc] initWithIdentifier:@"com.tr.toolkit.state-machine.start-state"];
}

@end

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@implementation TRPreviousState

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
+ (instancetype)state
{
    return [[[self class] alloc] initWithIdentifier:@"com.tr.toolkit.state-machine.previous-state"];
}

@end
